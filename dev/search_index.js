var documenterSearchIndex = {"docs":
[{"location":"quick-start/#快速入门-1","page":"快速入门","title":"快速入门","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"尽管本书不会过多关注基础入门知识，但是为了让我们的读者能够站在同一起跑线上，我们在这一节快速过一遍Julia的各种语法。 如果你已经对Julia很熟练了，那么不要浪费时间请跳过本节。如果你对Julia还不了解，我依然建议你完整阅读Julia官方文档的手册部分（Manual）， 这部分我删去了很多细节，而着重在相对深入的概念解释和针对一些有学习过其它语言的人的常见误区的解释。","category":"page"},{"location":"quick-start/#变量（Variable）-1","page":"快速入门","title":"变量（Variable）","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia语言中最基础的元素是变量，简单的来说变量就是一个绑定了一个值（value）的名字（name），例如","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = 1","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这里 x 是一个变量，它的名字叫 x，它的值是一个数字 1。但是一个名字并不需要唯一的绑定这个值，","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = \"我是一个变量的值\"","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"note: Note\n在 C/C++ 里，一个变量是唯一绑定一个类型的，并且对应内存地址。Julia的变量类似于 C++ 的引用（reference）， 但依然在语义上不完全一样。具体的一个体现就是Julia不能重载赋值运算符，因为由于变量只是绑定一个名字，所以不存在 需要重载赋值运算的场景。单独使用 = 永远只表示给右边的值绑定左边的名字。","category":"page"},{"location":"quick-start/#类型（Type）-1","page":"快速入门","title":"类型（Type）","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"类型是一种标记，它存在的目的是为了告诉编译器部分关于你代码的信息，或者简单来说，它是对变量的“分类”。Julia语言是一个 强类型（strong typed）语言，这意味着所有的变量/值都有一个类型。比如 1 的类型是 Int，你可以用 typeof(1) 来查看它。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"当我们把一个值绑定给一个变量之后，这个变量也自动具有了对应的类型","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = 1\ntypeof(x)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"如果你给这个变量赋予了新的值，那么变量的类型也会改变","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"x = \"我是一个变量的值\"\ntypeof(x)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而类型的类型是数据类型 DataType","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"typeof(Int)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"DataType 的类型还是 DataType","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"typeof(DataType)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在Julia里所有的变量都有一个类型，你可以用 typeof 来获取它。","category":"page"},{"location":"quick-start/#函数-1","page":"快速入门","title":"函数","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia是一个构建在多重派发（multiple dispatch）基础上的语言， 它的函数实际上是一般的，有些翻译里也称为范型的函数（generic function）。 而我们每一个具体的函数定义都会为这个函数增加一种方法（method），方法 是一种具体执行这个范型函数的方式。所以很自热的，我们可以声明没有任何方法的 函数","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而每一种不同的输入类型的组合都将创建一个新的方法，","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(x)\n   x + 1\n   return x\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这里 function 和 end 关键字作为标识函数声明的符号。 有人也许会有疑问，为什么Julia里要使用 end 作为结尾，而不是 {} 或者像 Python一样使用缩进呢？当你阅读到 表达式这一部分我想你就能够得到部分答案，当你掌握元编程之后，你便会体会到 end 的妙处。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"或者，你也可以使用更简洁的写法。但是注意由于这个声明和上一个声明的类型标签相同（都是一个 Any 类型的函数参数）","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"foo(x) = x + 1","category":"page"},{"location":"quick-start/#类型标注-1","page":"快速入门","title":"类型标注","text":"","category":"section"},{"location":"quick-start/#带类型标注的方法声明-1","page":"快速入门","title":"带类型标注的方法声明","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"我们还可以对函数参数加上类型标注（type annotation），这将具体规定这个方法所适配的类型，例如","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"foo(x::Int) = 2x","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"或者是更多的变量，不同类型的组合等等","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"foo(x::Int, y::Float32) = y\nfoo(x::Float32, y::Int) = x + y\nfoo(x, y) = 2x + y","category":"page"},{"location":"quick-start/#控制流-1","page":"快速入门","title":"控制流","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"一般来说，控制流包含两种。一种是循环表达式，一种是条件表达式。","category":"page"},{"location":"quick-start/#循环表达式-1","page":"快速入门","title":"循环表达式","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Julia中可以使用常见的两种方式定义循环，一种是 for 一种是 while。for 关键字后跟 in 关键字表示需要循环的区间","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(start)\n    for k in start:10\n        @show k\n    end\nend\n\nfoo(2)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"另外一种则是 while ","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(start)\n    k = start\n    while k < 10\n        @show k\n        k += 1\n    end\nend\n\nfoo(2)","category":"page"},{"location":"quick-start/#条件表达式-1","page":"快速入门","title":"条件表达式","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"条件表达式即 if ... else ... end，例如","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"function foo(x)\n    if x > 0\n        println(\"x 比 0 大\")\n    elseif x > -1\n        println(\"x > -1\")\n    else\n        print(\"x <= -1\")\n    end\nend\n\nfoo(1)\nfoo(-0.5)\nfoo(-1)","category":"page"},{"location":"quick-start/#自定义类型-1","page":"快速入门","title":"自定义类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"一般来说我们会使用两种组合类型（composite type），这些类型由其它的数据类型组合而来。而在Julia里有两种，一种是成员的值在定义之后可变的 类型，另外一种是成员的值在定义之后不可变的类型。类型在Julia中主要有两个作用：一是用来派发方法（method），二是用来包装数据结构。","category":"page"},{"location":"quick-start/#不可变类型-1","page":"快速入门","title":"不可变类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"不可变类型使用 struct 关键字进行声明（也就是说我们默认一个类型是不可变的），格式如下","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"struct Cat\n    name::String\nend","category":"page"},{"location":"quick-start/#可变类型-1","page":"快速入门","title":"可变类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"可变类型需要使用 mutable 关键字进行标注","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"mutable struct Cat\n    name::String\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"note: Note\n在Julia里，从语义上讲（semantically）我们不区分这两种类型对应的内存分配方式。但是在优化层面，尽管Julia没有提供 像C++一样的显式声明栈上分配的内存（stack allocated）的语义，但是通过对不可变等性质的推导，它依然可以和C++达到相近 的内存分配大小 [相关讨论]。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"[相关讨论]: 相关讨论可以参见discourse上的帖子:Why mutable structs are allocated on the heap?\nClarification about memory management of immutable and mutable struct","category":"page"},{"location":"quick-start/#参数类型-1","page":"快速入门","title":"参数类型","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在很多情况下，一些类型有着相近的含义和数据结构，但是它们需要派发的方法可能有所不同。这个时候我们往往会需要用到参数类型。 Julia中类型参数可以使用大括号 {} 声明。类型参数本身在编译时期也是有类型的，统一为 TypeVar 类型。例如下面这个文档 中也用到了的复数类型的例子。对于类型参数，我们可以使用 <: 来声明它的上界。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"struct Complex{T <: Number}\n    real::T\n    imag::T\nend","category":"page"},{"location":"quick-start/#数组-1","page":"快速入门","title":"数组","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"数组是一种特别的类型，和其它语言不同的是，在Julia我们的数组是多维数组（multi-dimensional array）。所谓数组， 实际上它是一种对内存的抽象模型。在Julia里一个数组类型（Array）的实例代表了一块连续的内存","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在Julia里它扮演了两种角色：计算机意义上的数组以及数学意义上的多维张量。 在很多机器学习框架中，也往往实现了多维数组或者张量（Tensor，例如PyTorch）。而这些 实现本质上只是一种对一块连续内存的查看方式。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"一般来说多位数组的实际数据结构如下","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"struct MyArray{T, N}\n    storage::Ptr{T}\n    size::NTuple{N, Int}\n    strides::NTuple{N, Int}\nend","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"其中 storage 是一个指向某块内存的指针，这块内存上存了一些 T 类型构成的元素 ，size 记录了这个多维数组的大小，strides 则 用来表示每个维度之间间隔的元素个数，什么意思呢？例如下表是一个有20个浮点类型（双精度）的内存块，它可能存储了一个4x5矩阵的值，也有可能存储了一个2x5x2的三阶张量的值。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"内存地址 0xf21010 0xf21018 0xf21020 cdots 0xf210a0 0xf210a8\n值 0.0 1.0 2.0 cdots 18.0 19.0","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"向系统申请这个内存块，在不再使用之后删除所分配的内存并不需要知道对应张量的大小。甚至有可能几个元素数目不同但是总数相同的张量（比如4x4,2x2x2x2,1x16的不同大小张量）可以通过用不同的 MyArray 共享一块内存。但当我们需要完成张量的一些运算，例如对于矩阵，他们的乘积（matrix product），点积（dot product）等运算会需要使用维度的信息（各个维度的大小）并且这个时候我们将按照维度来访问不同位置的元素，这使得我们首先需要存储各个维度的大小 size ，但是这还不够，我们实际上在访问一块连续内存的时候实际上使用的是不同维度上的间隔，例如第一个维度上的间隔一般是0，第二个维度上的间隔是第一个维度的大小size[0]，依次类推，但也有可能由于是由某个较大的张量分割来的，并不满足上述间隔分配方式，所以我们有必要再用一个数组存储各个维度的间隔大小 strides。这样在访问某个角标ijk对应的内存地址时就可以用","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"(i - 1) * strides[0] + (j - 1) * strides[1] + (k - 1) * strides[2]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"作为一个元素的真实内存地址了。当然Julia已经为我们做好了这些事情，在平时使用的时候我们不需要去在意它到底是怎么实现的。但是在我们后面的章节里，我们还会用到这些性质和定义。","category":"page"},{"location":"quick-start/#表达式-1","page":"快速入门","title":"表达式","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"在Julia里，任何一段程序都首先是一段表达式（expression）。所谓的表达式是一种数据结构，它存储了 一段程序的抽象语法树（abstract syntax tree）。我们可以用引用（quote）语法来获取一段程序的表达式","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex = :(1 + 2 * b)\ntypeof(ex)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而 ex 的类型则是 Expr 类型。而表达式中暂时没有值的变量则会被解析为一个符号，它的类型是 Symbol， 你可以通过 : + 一段合法的变量名 获得这样一个符号。它相当于一种特别的字符串。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"typeof(:a)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"Expr 类型里的结构很简单，它包括一个符号类型的头，作为这段表达式的标签，以及一个一维的 Any 类型数组， 这个数组将存储这个表达式的子表达式。这里 dump 将会打印出一个Julia对象的内部结构。","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"dump(Expr)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"我们不妨看看上面的表达式是什么样子的","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"dump(:(1 + 2 * b))","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这是什么意思呢？首先我们说抽象语法数会把这样一段表达式存储成如下的形式","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"(Image: AST-diagram)","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而上面的 Expr 就存储了这样一颗树，它的根结点是最低优先级的 + 函数的函数调用，","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex.head\nex.args[1]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"这个函数调用有两个输入，分别是","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex.args[2]\nex.args[3]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"而第二个输入则是另外一段表达式（的结果），这段表达式是* 函数的函数调用","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"ex.args[3].head\nex.args[3].args[1]\nex.args[3].args[2]\nex.args[3].args[3]","category":"page"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"于是最终通过嵌套 Expr 这样的一个节点和 Symbol 类型这样的叶子节点，我们构成了一颗树。","category":"page"},{"location":"quick-start/#再谈谈函数-1","page":"快速入门","title":"再谈谈函数","text":"","category":"section"},{"location":"quick-start/#","page":"快速入门","title":"快速入门","text":"所以我们之前的方法将会被覆盖。在Julia里，函数声明是可以不用写 return 关键字的，所有的函数在没有显式（explicitly） 声明 return 关键字的时候都将默认返回整段表达式中的最后一个表达式。","category":"page"},{"location":"quick-start/#变量的作用域-1","page":"快速入门","title":"变量的作用域","text":"","category":"section"},{"location":"quick-start/#语法糖（Syntax-Sugar）以及一些语法的等价性-1","page":"快速入门","title":"语法糖（Syntax Sugar）以及一些语法的等价性","text":"","category":"section"},{"location":"workflow/#Julia程序编写流程-1","page":"程序的编写流程","title":"Julia程序编写流程","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"如果你已经熟悉其它程序的编写流程，那么你可以考虑跳过这一部分，但是我还是建议你最后能够快速的 过一下这部分，因为Julia作为一门JIT编译的语言，有时候在编写上，相比解释型语言会有一些明显的延迟（latency）。 下面的编写流程主要是为了帮助你绕过这个延迟的。","category":"page"},{"location":"workflow/#terminal_and_repl-1","page":"程序的编写流程","title":"终端（Terminal）和REPL","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"如果你使用Windows，你可以选择忽略终端这部分","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"如果你通过在终端输入命令 julia 或者点击Julia图标，打开Julia的编译器，你将会进入一个称为REPL的界面， 这是 “read-eval-print loop“的缩写，也就是说它提供了一个读取一小段程序，然后运行，再将程序的输出打印 出来的循环。这对于调试程序，临时测试一些小的脚本来说非常方便。此外你也可以通过在REPL里 include(\"你的脚本.jl\") 来运行你的脚本文件。","category":"page"},{"location":"workflow/#编译器（Compiler）-1","page":"程序的编写流程","title":"编译器（Compiler）","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"但是对于完整的脚本和工程来说，REPL并不是一个好的选择，虽然你依然可以通过 include(\"你的脚本.jl\") 来运行程序， 但是通过直接执行编译器命令，你可以和shell脚本等工具进行交互，并且你可以很好的管理一些编译器选项。你可以通过","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"julia 你的脚本.jl","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"来运行一个脚本，此外Julia编译器还有诸多编译器选项可以通过 julia --help 来查看。","category":"page"},{"location":"workflow/#编辑器（Editor）和-集成开发环境（IDE）-1","page":"程序的编写流程","title":"编辑器（Editor）和 集成开发环境（IDE）","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"有很多刚刚接触编程的朋友分不清楚编译器和编辑器的区别，所以我在这里简单的说明一下：编译器是负责将描述程序的文本文件， 编译成机器码（或者其它格式）的 ”翻译机“，而编辑器则是辅助你编写程序的软件，常见的编辑器包括：vscode，atom，vim，emacs 等等。","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"集成开发环境则是集成了一整套开发环境的软件，这包括：编辑器，编译器，调试器和用户图形界面等等工具。这其中就包括CLion，visual studio等等。但是新兴的语言往往不再选择以这种方式来支持开发，原因是现代插件化的编辑器已经能够通过安装插件提供同样的功能，而 开发插件也会大大降低维护的成本，并且提供了更多个性化定制的可能性。","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"Julia语言也是类似的，Julia社区提供了以下这些编辑器的支持：","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"vim/emacs\natom\nvscode\nJetbrain (CLion, PyCharm, etc.)\nctags\nnotepad++\nsublime","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"我个人推荐不熟悉Julia的朋友选择atom上的Juno插件，这个插件是Julia社区中发展时间最长的插件，相比于其它插件也更加成熟， 对画图，调试的支持也更好。其次我推荐使用vscode，这个编辑器本身是非常优秀的作品，即便它的Julia插件还处于比较初步的开发阶段。 另外我也推荐熟悉Jetbrain生态的朋友使用Jetbrain上的Julia插件，你可以通过在CLion或者PyCharm里安装这个Julia插件来使用它。","category":"page"},{"location":"workflow/#代码的热加载-1","page":"程序的编写流程","title":"代码的热加载","text":"","category":"section"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"由于Julia编译器使用了即时编译技术（JIT），在每次运行一个函数之前都会进行编译，这导致在第一次运行的时候，如果是比较大段的代码 则会出现一定的延迟，此外我们也不需要频繁地退出和进入REPL来运行新定义的函数，所以我们需要代码的热加载。所谓热加载就是指不退出 REPL来更新函数定义，从而加载更新后的代码。这个工具叫：Revise 安装它只需：","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"pkg> add Revise","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"使用方法也很简单，只要在加载你将会修改的模块前加载它即可","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"using Revise, 你将会修改的模块","category":"page"},{"location":"workflow/#","page":"程序的编写流程","title":"程序的编写流程","text":"当然，如果你觉得这还是很麻烦，你可以在你的vscode插件设置中勾选 Julia: use Revise 这个选项即可。或者将它加入你的 startup.jl 文件中，这样每次启动REPL都会加载这个package。","category":"page"},{"location":"before-we-start/#在开始之前-1","page":"在开始之前","title":"在开始之前","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"在正式开始学习之前，我们先来说说一些比较基本的问题。这些问题并不是很技术性，但是它能够让你日常的 编码任务变得更加顺滑，也能够为你在日后遇到困难的时候提供一个寻找帮助的方向。","category":"page"},{"location":"before-we-start/#如何安装Julia-1","page":"在开始之前","title":"如何安装Julia","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"如何安装Julia呢？一般来说我个人推荐直接安装Julia的编译器（compiler），然后再配置好一款你喜欢的编辑器（editor）。所以我先介绍这个流程。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"首先去Julia英文官网的下载页面，里面列出了一系列的下载资源。第一个是最新的稳定版本（current stable release），根据自己的系统配置选择合适的下载包即可。Linux用户可以选择直接使用 Generic Linux Binaries。然后接下来是非常稳定的长期支持版本， 目前是 v1.0.x 版本，x代表某个小版本，它会不断更新。最后是最新的不稳定版本（nightly build），你可以通过下载它预览很多新功能，但是因为它是开发版本，所以可能有bug，会出现莫名其妙的错误等等。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"Julia编译器的版本号使用语义化版本 2.0.0进行标注，格式为 X.Y.Z，这里 X 版本在 X 大于等于1的时候都是兼容的，而每个次版本号 Y 则代表增加了向下兼容的功能性新增，Z是修订号，代表向下兼容的问题修正（比如某个补丁）。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"具体安装的细节就不同的系统而不同。","category":"page"},{"location":"before-we-start/#Linux-1","page":"在开始之前","title":"Linux","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"作为开源软件，Linux系统可能往往是支持最好的。你仅需把这个压缩包下载下来放在你喜欢的目录下即可。为了方便我们一般会在shell的配置文件里添加可执行文件的路径。找到你的配置文件，例如一般Ubuntu默认的是bash，","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"cd ~","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"然后找到 .bashrc 文件（对其它类型的shell，比如zsh，这个文件叫 .zshrc)，然后添加下面这样一行命令","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"export PATH=\"<到你的bin目录路径，例如/usr/local/bin>:$PATH\"","category":"page"},{"location":"before-we-start/#macOS-1","page":"在开始之前","title":"macOS","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"macOS实际上和Linux非常类似，这也就是说上面这套在Linux上安装Julia的方法也可以用在macOS上，但是如果你下载的是官方的 .dmg 文件，那么 按照正常的macOS应用进行安装即可，Julia的编译器将会出现在你的 Application 文件夹中。","category":"page"},{"location":"before-we-start/#Windows-1","page":"在开始之前","title":"Windows","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"我不用Windows，希望有人可以补充","category":"page"},{"location":"before-we-start/#从源码编译-1","page":"在开始之前","title":"从源码编译","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"对于有一定能力，和背景知识的同学，你也许会尝试从源码编译。在一些机器上，通过个性化的配置这确实有助于你获得最佳的性能。此外，由于Julia编译器本身 自带了庞大的标准库（这包括线性代数等等），你也许并不需要使用他们，而只是想使用一个体积最小的编译器等等如此的个性化需求都可以通过从源码编译来实现。 Julia的编译器团队提供了充分多的选择来支持这些特点。","category":"page"},{"location":"before-we-start/#如何安装包（package）-1","page":"在开始之前","title":"如何安装包（package）","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"很简单，打开你的Julia，它也称为REPL。然后按 ] 键即可进入 pkg 模式，你将会看到左边从 julia>变成了 pkg， 之后输入 add XXX 即可安装名为 XXX 的包。","category":"page"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"pkg> add XXXX","category":"page"},{"location":"before-we-start/#如何获取帮助-1","page":"在开始之前","title":"如何获取帮助","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"Julia作为一门新的编程语言，它的社区不会有老牌语言大，它在网上现成的资料不会有老牌语言多。所以遇到问题你需要知道去哪里获取相关的帮助。","category":"page"},{"location":"before-we-start/#提问的艺术-1","page":"在开始之前","title":"提问的艺术","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"在此之前，根据过去的经验，我觉得非常有必要介绍这一点。在你问问题的时候请遵守 提问的艺术。这 非常重要，因为方便为你解答问题的人，遵守礼仪才能让你更好的成长和获得帮助。","category":"page"},{"location":"before-we-start/#善用搜索-1","page":"在开始之前","title":"善用搜索","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"一般来说在Google搜索里直接输入相关的问题就可以找到你想要的答案，如果结果和Julia语言无关，加上 Julia语言 或者 Julia Language  即可。但是在国内的朋友可能无法使用Google，那么使用必应一般也能够搜索到相关的结果。中文社区同时也建立了中文论坛，网络上大部分关于Julia相关 问题的中文回答都以论坛的帖子作为形式出现，你可以使用论坛的搜索来寻找你的问题。","category":"page"},{"location":"before-we-start/#去论坛提问-1","page":"在开始之前","title":"去论坛提问","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"Julia的中文社区和英文社区都是比较活跃的，并且有英文论坛和中文论坛两个论坛的支持。英文论坛上的人相对更多，是大部分开发者的主要活动区域，如果你有比较复杂的问题往往可以在这里找到开发者本人的回答。如果你的英文不好，或者倾向于帮助中文世界积累更多的资料，那么中文论坛也是一个很好的选择，并且你还可以在中文论坛上找到更多针对中文用户的帮助（例如网络导致的下载问题的帮助，字符格式问题等等）。","category":"page"},{"location":"before-we-start/#去聊天室提问-1","page":"在开始之前","title":"去聊天室提问","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"我个人一般不鼓励大家去聊天室提问，因为这不利于你组织问题，方便为你解答的人。 但是在聊天室提问或者讨论问题又确实是最方便的。Julia官方使用slack作为聊天室， 你可以通过这个地址来加入Julia官方的 slack群组。此外Julia中文社区还有一个QQ群，群号是：316628299。","category":"page"},{"location":"before-we-start/#参加线下活动-1","page":"在开始之前","title":"参加线下活动","text":"","category":"section"},{"location":"before-we-start/#","page":"在开始之前","title":"在开始之前","text":"现在活动可能是解决问题最方便的场所，这个时候你可以当面问其它使用Julia的人（我们称之为Julian），从而获得最佳的帮助效果。 但是也请注意遵守下面介绍的提问的艺术。Julia中文社区和Julia英文官网都经常举办相关的线下活动，每年最大的 线下活动是Julia会议，你可以访问 Julia会议官网 获得最新的会议日程。","category":"page"},{"location":"automatic-differentiation/#自动微分-1","page":"实现你自己的自动微分","title":"自动微分","text":"","category":"section"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"自动微分（automatic differentiation）技术在机器学习里也叫做后向传播，它的原理实际上是通过记录运算顺序，利用已经定义好的导数规则，生成一个正常计算程序对偶的程序。一般来说有两种自动微分方式，一种是前向自动微分（Forward Automatic Differentiation）另外一种是后向自动微分（Reverse Automatic Differentiation），后者更加适合多参数的情况（算法细节就不详述了，多参数的时候后向自动微分的时间复杂度更低，一次传播可以计算所有的参数）。 后向自动微分会讲所有的操作以一张图的方式存储下来，这张图称为计算图。这也是各大深度学习框架的核心所在——如何干净地产生一个计算图，然后高效计算它。 为了展示计算图是什么，我从Cornell，CS5740，2017sp这门课的课件里搬运了一些图，然后把他们做成了动画。动画使用纯Julia的框架Luxor制作。","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们以计算下面这个表达式为例：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"y = mathbfx^T mathbfA mathbfx + mathbfb cdot mathbfx + c","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"我们将会调用这样一些Julia函数来计算它：","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"z_1 = x^T\nz_2 = z_1 A\ny_1 = z_2 x\ny_2 = b cdot x\ny_1 + y_2 + c","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"而实际上我们可以把这个过程画成下面的这个图","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"(Image: forward)","category":"page"},{"location":"automatic-differentiation/#","page":"实现你自己的自动微分","title":"实现你自己的自动微分","text":"(Image: backward)","category":"page"},{"location":"define-your-own-matrix/#实现你自己的稀疏矩阵-1","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"","category":"section"},{"location":"define-your-own-matrix/#","page":"实现你自己的稀疏矩阵","title":"实现你自己的稀疏矩阵","text":"Julia语言有着世界上最好的矩阵和数组生态，这得益于Julia语言的类型系统（type system）和多重派发（multiple dispatch）。 在这一部分，我们将通过自己实现一个稀疏矩阵类型来体验这一点。","category":"page"},{"location":"define-your-own-matrix/#一些关于稀疏矩阵的基础知识-1","page":"实现你自己的稀疏矩阵","title":"一些关于稀疏矩阵的基础知识","text":"","category":"section"},{"location":"define-your-own-matrix/#Julia语言中的接口定义（Interface）-1","page":"实现你自己的稀疏矩阵","title":"Julia语言中的接口定义（Interface）","text":"","category":"section"},{"location":"define-your-own-matrix/#Julia语言中的广播机制-1","page":"实现你自己的稀疏矩阵","title":"Julia语言中的广播机制","text":"","category":"section"},{"location":"define-your-own-matrix/#Holy-Trait-1","page":"实现你自己的稀疏矩阵","title":"Holy Trait","text":"","category":"section"},{"location":"#Julia编程指南-1","page":"简介","title":"Julia编程指南","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"Julia语言在2018年正式发布了第一个长期支持版本（1.0版本），在这之后市面上出现了很多中文教程。但是， 为什么我还要编写本书呢？有如下的一些原因：","category":"page"},{"location":"#","page":"简介","title":"简介","text":"市面上的中文书籍和教程主要都以入门Julia语言为主。但是还没有一本由有经验的Julia语言开发者所编写的书籍。\n我们在中文社区的论坛，QQ群等中文媒体上经常可以看到中文用户抱怨没有好的教材可以参考，缺乏可以学习的代码范例，并且中文网络上依然大量充斥着旧版Julia的代码（Julia 0.6甚至是更加古老的版本）。这些旧的代码随着1.0版本的发布已经不再支持，对很多Julia学习者造成了困扰。\n我发现由于Julia语言编程范式和其它流行语言（例如Python，C++，MATLAB）有很大不同，有很多Julia学习者在阅读过文档之后，即便已经学会了基本语法，大部分Julia学习者入门之后依然无法很好的编写一个完整的，符合Julia范式的代码库。\n我们有时候还是需要一些文档里不会讲的内容，比如一些经验性质的总结，一些更加和某个领域相关的完整工程展示。所以这也是这本书的目的之一：提供编写Julia工程的实践范例\n我在知乎上写过很多零散的关于Julia语言的文章，有很多人建议我将它们整理到一起，但是我不是很喜欢知乎的编辑器，它并不适合编写长篇的技术文章，对数学公式和代码的支持非常差。而微信公众号则更加糟糕，在经过调研后我觉得还是需要使用开源工具自己来做这件事情。\n大部分的书籍依然是传统的纸质媒体，或者以纸质媒体为前提进行编写。这在现在这个互联网和富文本时代是非常落后的。我希望以此为媒介，做一些现代书籍的实验。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"本书使用纯Julia进行编写，除了构成静态网页的js/html/css 脚本以外，这本书的Julia纯度为：100%，当你下载这本书之后，可以用Julia的编译器运行下面这行命令","category":"page"},{"location":"#","page":"简介","title":"简介","text":"在命令行里","category":"page"},{"location":"#","page":"简介","title":"简介","text":"julia make.jl","category":"page"},{"location":"#","page":"简介","title":"简介","text":"或者打开Julia的REPL，然后运行","category":"page"},{"location":"#","page":"简介","title":"简介","text":"include(\"make.jl\")","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这本书就会以网页的形式挂在到 localhost:8000，它使用了 Documenter 和 LiveServer 这两个Julia包进行编译和挂载。如果你喜欢黑夜模式（dark mode） 你还可以点击右上角的齿轮按钮选择黑夜模式。","category":"page"},{"location":"#Julia语言的定位是什么？-1","page":"简介","title":"Julia语言的定位是什么？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"Julia是主要用来做科学计算吗？是的，Julia主要用来做科学/技术计算（Scientific Computing），实际上在1.0以前Julia的REPL启动之后都有一句：A Fresh Approach To Technical Computing。这意味着社区的主要关注点在科学计算上，但这不是说Julia只能做科学计算。实际上构建网站，挖比特币，图形界面等等都有相关的package。但是我们说社区的主要关注点在科学计算，所以相比诸如Python/Go/Erlang的这些类似功能，Julia的这些功能更多的是为了服务于科学计算，而不是和已有的软件同台竞争。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"但Julia本身的定位和很多其它语言一样：一个通用编程语言。","category":"page"},{"location":"#为什么要设计一个新语言？原先的解决方案有什么问题？-1","page":"简介","title":"为什么要设计一个新语言？原先的解决方案有什么问题？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"我知道很多人提到Julia都想到性能。但是我不想从性能讲，因为Julia并不单纯的是要解决性能问题，Julia要解决的是一个有前提的性能问题：如何在让程序足够通用（generic）的前提下，尽可能提供最好的性能。Julia为了解决这个问题成为了第一个为JIT编译设计的语言，也是第一个实现了高性能的多重派发（multiple dispatch）的语言。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"当你开始使用Julia以后，你会发现不同于Python/MATLAB/C++/C的是，大部分时候我们只要关心数学对象，我们写的代码都非常的generic，于是非常多的功能通过多重派发和类型系统只要数学上讲得通，就自动工作了，不需要写额外的代码把他们组合在一起。例如曾经在社区里发生过一个很经典的事情：DifferentialEquations的作者有一天发现，有一个他完全不认识的人写了一个误差分析的库（Measurements），定义了一种数，带误差上下界，结果放进微分方程的求解器里什么都没有算，就自动能够工作用来分析误差。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"所以有很多Julia用户的观点是：即便Julia的性能不好（其实挺不错的），这种新的编程范式本身就足够吸引人了。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这个问题我在之后还会更加详细的以长篇幅讨论，如果你想现在阅读也可以直接跳到这部分：","category":"page"},{"location":"#Julia官方宣称自己很快，但是再快能有C/C/Fortran快吗？-1","page":"简介","title":"Julia官方宣称自己很快，但是再快能有C/C++/Fortran快吗？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"首先我们要解释一下误区，我遇到过很多人都持有这样的观点：如果我用一个静态编译语言实现我的功能，它就会很快。这是错误的，一段代码快不快并不取决于它使用什么语言编写，而是取决于它具体做了什么，它所实现的算法时间复杂度是多少。在很多情况下，用静态语言写的实现更快只是因为静态语言的编译机制强制你写出能够被编译器充分优化的代码（但有时候也许没有必要）。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"比如 AutoTVM 可以用Python的API找出一个比MKL快的kernel，这个算不算Python更快呢？所以实际上，如果你不在乎性能，Julia可以像Python解释器一样慢，但是如果你在乎性能，不同于Python的是Julia也为优化提供了充分的可能性。例如你可以用纯Julia，以高级语言的特性实现BLAS的gemm routine，它的性能可以接近手工调整汇编指令的OpenBLAS。而注意这个矩阵乘法的实现本身是一般的，它没有用到任何特殊的语义，它是使用Julia本身的语法表达了矩阵的分块等语义。也就是说它不仅可以使用32和64位浮点，对于其它的Julia类型也能够工作。这就是我们说的在代码足够一般的前提下，依然能够获得非常好的性能。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"(Image: JuliaBLAS-benchmark)","category":"page"},{"location":"#","page":"简介","title":"简介","text":"矩阵乘法能够在一定程度上说明即便是稍微复杂一些的任务，Julia也能够拥有不错的性能。而实际上由于社区本身对科学计算的重视，我们会发现当我们实现一个完整的工程之后，往往要比同类软件的C++版本快。这往往是因为在Julia里已经有了丰富的基础生态（例如各种特殊矩阵算法的实现，各种线性代数算法的实现）同时实现各种特化的算法代价又非常的低，同样的接口组合下不同的类型就可以了，最后导致的结果就是即便编译器本身做的优化并不如GCC/Clang，最终的效果却可能更快。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"当然了，说到这里有人可能还是不信，我最近刚好在给我们的量子计算框架做benchmark，其中 ProjectQ 是一个非常标准的 pybind11 C++/Python 程序，使用了C++大量优化了性能，并且是第一个实现量子霸权模拟(45 比特的全概率幅模拟）的软件。而 qulacs 和 QuEST 则是使用了大量C++进行优化了的高性能模拟器。但是我们依然能够通过精心设计的软件架构，大量的使用通用性的特化代码，用纯Julia就实现了更好的性能和更多的功能","category":"page"},{"location":"#","page":"简介","title":"简介","text":"(Image: parameterized)","category":"page"},{"location":"#","page":"简介","title":"简介","text":"而实际的代码量却远远小于C++的实现。","category":"page"},{"location":"#既然多重派发这么好，为什么在Julia之前没有语言大规模使用？-1","page":"简介","title":"既然多重派发这么好，为什么在Julia之前没有语言大规模使用？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"实际上并不是这样，在Julia之前有非常多的语言社区都尝试实现过多重派发，甚至曾经出现过以多重派发为主要范式的语言。但是他们都有一个严重的问题：这些多重派发的实现性能都不好，以至于最终无法应用到实际的生产环境里去。Julia的出现也是站在这些前辈的探索之上的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"那么Julia是如何解决这个问题的呢？这要说到Julia最大的特点：对JIT编译友好的语言设计。Julia在设计之初就以JIT编译为假定，而非解释执行或者静态编译（AOT）。 完整的多重派发本身是一种动态特性，这是因为变量的类型并不一定能够完全在编译时期确定，所以我们也说类似C++的函数重载是静态的多重派发，但是C++本身并不支持动态的多重派发，实现类似的功能需要虚表。而Python社区里也有多重派发的实现，但是Python由于本身是以解释器为基础设计的，所以这些多重派发的实现本质上也都只是存储了一个动态的方法表，然后在运行时期来查找。这就导致性能甚至比使用Python自带的class的单重派发+继承还差。类似的在其它语言里也有类似的实现，他们或者因为静态编译，对动态的多重派发支持不好，或者因为本身是动态地解释执行，最终的性能很差。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"而Julia通过结合JIT解决了这个问题，Julia的编译过程是动态的，每次编译发生在函数被调用之前。这就意味着当编译器能够正确推导出类型的时候，我们就可以进行静态派发，当编译器无法推导类型的时候，我们自动进行动态派发。这表现为Julia语言的类型稳定性（type stability）。而所有的编译都以函数为界。这也就是说，如果函数 f1 是类型不稳定的，但是实际的程序中它的输出输入到一个类型稳定的函数 f2里，Julia依然能够被静态编译f2，使得f2内部的函数派发变成静态的。","category":"page"},{"location":"#Julia解决了什么问题？-1","page":"简介","title":"Julia解决了什么问题？","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"想想我们一开始为什么会用Python/MATLAB，他们起初也没什么生态不是么？但是它们在十年二十年前解决了科学计算的什么痛点呢？ 用Fortran95或者C/C++（除去C++11以后的版本，这个后面另外讨论）写出来的代码通用性差，往往只能针对特别的问题，编写程序的过程中，因为要不断的考虑类型的问题，我们往往花了很多的时间在思考如何写出能够让编译器通过的代码这件事上。而且非常多的场景下，我们只是需要一个类似计算器的东西，给你几个矩阵，告诉我结果就行了。我们不想去思考内存布局，类型是 A<Float32, Int> 还是 B<Float32, C<Float32>> 。甚至连面向对象都懒得管。至于具体的语法细节，什么goto，范型等其实都不是那么的重要（有很多替代方案），甚至如果你想在 Fortran95 中使用泛型（generic type）都是可能的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"Python/MATLAB 通过使用动态性，在一定程度上解决了以上问题。它们都可以简单地被当作计算器来用，快速的告诉你想知道事情，而不需要在乎类型推导是否能够通过，也不需要等待重新编译的时间。而说到底在我们编写的很多程序中，有一大部分的性能是无所谓的，我们只需要一些关键的地方足够快就行了，所以解释执行也是没有关系的。而Python本身的class实际上由于其动态性，它可以被当成鸭子类型（duck type）来使用的。每个class都可以动态的插入方法。所以当我们判断一个类型是什么的时候我们不再考虑这是什么类型，而是相对的考虑这个类型能做什么事情。这为很多代码带来很强的通用性，这意味着我不必在乎这个类型是谁的子类，反正它能做这件事（比如某个类型是具有对称性的，它是一个Hermitian的算符），那它就能够输入给任何只使用这个接口的函数。如果我写着写着，突然发现我需要用这个方法，我临时往我的类型里插入这个API也都是可以的。这是Python的动态性带来的方便之处。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"再比如，如果有在诸如C++这类静态语言里实现过多维数组的同学也许会注意到，我们很多时候希望能够在模板参数里带上一个维度作为参数，这样可以利用类型推导减少很多不必要的check，以及保证程序的正确性，并且通过对类型参数的特化来派发一些针对性的优化，甚至更加激进一些，我们可以把shape也放进模板里，这样在维度不大的时候展开for循环，手动编写针对小矩阵的优化。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"但是这样的静态特性在使用的时候又反而带来不方便，强制运行的类型推导有时候给一些小任务带来了很大的负担。例如我们很多人都用过Python的numpy，里面有一个einsum的功能，它提供了爱因斯坦求和标记来计算多个高维张量（也就是ndarray）的缩并，或者说求和。那么这个计算结果是一个张量，这个张量的大小和维度信息有可能是动态计算出来的，也有可能是能够在编译时期推导出来的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这在Fortran和C/C++里都是不行的或者说想要实现类似的特性是更加麻烦的。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"但是，对性能需求大的部分，我们就需要精心设计了，过于动态的语义虽然方便，但是它使得编译器能够做的假设就更少。而编译器想要优化代码，必须要有足够的假设来证明优化前后的代码是等价的才行。所以我们选择用语义上能够提供这些信息给编译器的语言来编写。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"这就是著名的两语言问题。我们用一种脚本语言提供方便的接口，用一个静态语言编写有性能需求的地方。这确实在很长一段时间，甚至直到现在都能够很好的解决很多问题。但是同时也造成了很多的问题，尤其是代码的通用性。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"例如，我们在MATLAB或者Python的CPU上的矩阵乘法往往是通过调用使用汇编优化的，这些代码分别针对两种浮点数（32和64）进行了优化。但是它们不能在其它类型上工作，并且组合不同类型的矩阵，由于缺乏足够一般（generic）的实现，导致我们需要大量的人工工作。但是反观Julia，一个典型的例子就是大量的自定义数组。我常常说：Julia有现在所有语言里最好的矩阵和多维数组生态。让我简单列举一下：","category":"page"},{"location":"#标准库-1","page":"简介","title":"标准库","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"LinearAlgebra：定义了几个常用的矩阵类型 Hermitian，Symmetric，Diagonal","category":"page"},{"location":"#特殊数组-1","page":"简介","title":"特殊数组","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"StaticArrays 栈上的静态数组：通过编译器提供高性能的小矩阵计算\nFillArrays 一些特殊的稀疏矩阵，例如零矩阵，全是某个数的矩阵等等\nInfiniteArrays 无穷维矩阵/数组\nBlockArrays 分块数组\nLazyArrays 懒惰求值的Array\nAxisArrays 每个维度可以带标签的数组（也就是PyTorch所谓的NamedTensor）","category":"page"},{"location":"#特殊矩阵（2维数组）-1","page":"简介","title":"特殊矩阵（2维数组）","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"ToeplitzMatrices \nBandedMatrices\nSpecialMatrices：这个包里实现了一些特殊矩阵包括 Cauchy，Circulant，Campanian，Frobenius等十一种特殊矩阵（太多了就不一一列举了）\nCovarianceMatrices\nLuxurySparse（这是我们自己开发的）：PermMatrix（广义交换矩阵），各种静态数组和上面的特殊矩阵组合的一些特化的实现","category":"page"},{"location":"#针对分布式和多进程的数组-1","page":"简介","title":"针对分布式和多进程的数组","text":"","category":"section"},{"location":"#","page":"简介","title":"简介","text":"标准库里的：SharedArray，可以在进程中共享内存\nDistributedArray，分布式的（稠密）数组，支持一些基本操作例如分布式乘法","category":"page"},{"location":"#","page":"简介","title":"简介","text":"为什么会有这么多矩阵和数组，因为在Julia里实现一个特殊矩阵的代价非常低，我们很容易就能做到让一个新的矩阵类型加入到整个生态里去，然后拥有包括基本的线性代数在内的各种功能。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"而这些数组和矩阵并没有特别地为很多其它算法实现什么，例如指数矩阵乘向量（expv）算法在ExponentialUtils里只假定这是一个数学上讲得通的线性映射，只要你能使用乘法，那么就可以在这个算法里运行，并且编译器会通过类型推导特化你的代码，从而获得最优的性能。而作者在实现ExponentialUtils的时候并不需要知道这个具体是一个什么矩阵。","category":"page"},{"location":"#","page":"简介","title":"简介","text":"所以多重派发是Julia高性能的基石，也是为什么大家喜欢用Julia写科学计算代码的主要原因之一。它确实大大降低了工作量。","category":"page"}]
}
